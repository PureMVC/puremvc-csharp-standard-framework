<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PureMVC</name>
    </assembly>
    <members>
        <member name="T:PureMVC.Core.Controller">
            <summary>
            A Singleton <c>IController</c> implementation.
            </summary>
            <remarks>
            	<para>In PureMVC, the <c>Controller</c> class follows the 
            	'Command and Controller' strategy, and assumes these 
            	responsibilities:</para>
            	<list type="bullet">
            		<item> Remembering which <c>ICommand</c>s 
            		are intended to handle which <c>INotifications</c>.</item>
            		<item> Registering itself as an <c>IObserver</c> with 
            		the <c>View</c> for each <c>INotification</c> 
            		that it has an <c>ICommand</c> mapping for.</item>
            		<item> Creating a new instance of the proper <c>ICommand</c> 
            		to handle a given <c>INotification</c> when notified by the <c>View</c>.</item>
            		<item>Calling the <c>ICommand</c>'s <c>execute</c> 
            		method, passing in the <c>INotification</c>.</item>
            	</list>
            	<para>
            	    Your application must register <c>ICommands</c> with the 
            	    <c>Controller</c>.
            	</para>
            	<para>
            	    The simplest way is to subclass <c>Facade</c>, 
            	    and use its <c>initializeController</c> method to add your 
            	    registrations.
            	</para>
            </remarks>
            <seealso cref="T:PureMVC.Core.View"/>
            <seealso cref="T:PureMVC.Patterns.Observer.Observer"/>
            <seealso cref="T:PureMVC.Patterns.Observer.Notification"/>
            <seealso cref="T:PureMVC.Patterns.Command.SimpleCommand"/>
            <seealso cref="T:PureMVC.Patterns.Command.MacroCommand"/>
        </member>
        <member name="M:PureMVC.Core.Controller.#ctor">
            <summary>
            Constructs and initializes a new controller
            </summary>
            <remarks>This <c>IController</c> implementation is a Singleton, 
                so you should not call the constructor 
                directly, but instead call the static Singleton
                Factory method <c>Controller.getInstance(() => new Controller(SingletonKey))</c>
            </remarks>
            <exception cref="T:System.Exception">Thrown if Singleton instance has already been constructed</exception>
        </member>
        <member name="M:PureMVC.Core.Controller.InitializeController">
            <summary>
            Initialize the Singleton <c>Controller</c> instance
            </summary>
            <remarks>
                <para>Called automatically by the constructor</para>
                <para>
                    Please aware that if you are using a subclass of <c>View</c>
                    in your application, you should also subclass <c>Controller</c>
                    and override the <c>initializeController</c> method in the following way:
                </para>
                <example>
                    <code>
                        // ensure that the Controller is talking to my IView implementation
                        public override void initializeController()
                        {
                            view = MyView.getInstance(() => new MyView());
                        }
                    </code>
                </example>
            </remarks>
        </member>
        <member name="M:PureMVC.Core.Controller.GetInstance(System.Func{PureMVC.Interfaces.IController})">
            <summary>
            <c>Controller</c> Singleton Factory method.
            </summary>
            <param name="controllerFunc">the <c>FuncDelegate</c> of the <c>IController</c></param>
            <returns>the Singleton instance of <c>Controller</c></returns>
        </member>
        <member name="M:PureMVC.Core.Controller.ExecuteCommand(PureMVC.Interfaces.INotification)">
            <summary>
            If an <c>ICommand</c> has previously been registered 
            to handle a the given <c>INotification</c>, then it is executed.
            </summary>
            <param name="notification">note an <c>INotification</c></param>
        </member>
        <member name="M:PureMVC.Core.Controller.RegisterCommand(System.String,System.Func{PureMVC.Interfaces.ICommand})">
            <summary>
            Register a particular <c>ICommand</c> class as the handler 
            for a particular <c>INotification</c>.
            </summary>
            <remarks>
                <para>
                    If a <c>ICommand</c> has already been registered to 
                    handle <c>INotification</c>s with this name, it is no longer
                    used, the new <c>Func</c> is used instead.
                </para>
                <para>
                    The Observer for the new ICommand is only created if this the
                    first time an ICommand has been regisered for this Notification name.
                </para>
            </remarks>
            <param name="notificationName">the name of the <c>INotification</c></param>
            <param name="commandFunc">the <c>Func Delegate</c> of the <c>ICommand</c></param>
        </member>
        <member name="M:PureMVC.Core.Controller.RemoveCommand(System.String)">
            <summary>
            Remove a previously registered <c>ICommand</c> to <c>INotification</c> mapping.
            </summary>
            <param name="notificationName">the name of the <c>INotification</c> to remove the <c>ICommand</c> mapping for</param>
        </member>
        <member name="M:PureMVC.Core.Controller.HasCommand(System.String)">
            <summary>
            Check if a Command is registered for a given Notification 
            </summary>
            <param name="notificationName"></param>
            <returns>whether a Command is currently registered for the given <c>notificationName</c>.</returns>
        </member>
        <member name="F:PureMVC.Core.Controller.view">
            <summary>Local reference to View</summary>
        </member>
        <member name="F:PureMVC.Core.Controller.commandMap">
            <summary>Mapping of Notification names to Command Class references</summary>
        </member>
        <member name="F:PureMVC.Core.Controller.instance">
            <summary>Singleton instance</summary>
        </member>
        <member name="F:PureMVC.Core.Controller.Singleton_MSG">
            <summary>Message Constants</summary>
        </member>
        <member name="T:PureMVC.Core.Model">
            <summary>
            A Singleton <c>IModel</c> implementation
            </summary>
            <remarks>
                <para>In PureMVC, the <c>Model</c> class provides access to model objects (Proxies) by named lookup</para>
                <para>The <c>Model</c> assumes these responsibilities:</para>
                <list type="bullet">
                    <item>Maintain a cache of <c>IProxy</c> instances</item>
                    <item>Provide methods for registering, retrieving, and removing <c>IProxy</c> instances</item>
                </list>
                <para>
                    Your application must register <c>IProxy</c> instances
                    with the <c>Model</c>. Typically, you use an 
                    <c>ICommand</c> to create and register <c>IProxy</c> 
                    instances once the <c>Facade</c> has initialized the Core actors
                </para>
            </remarks>
            <seealso cref="N:PureMVC.Patterns.Proxy"/>
            <seealso cref="T:PureMVC.Interfaces.IProxy" />
        </member>
        <member name="M:PureMVC.Core.Model.#ctor">
            <summary>
            Constructs and initializes a new model
            </summary>
            <remarks>
                <para>
                    This <c>IModel</c> implementation is a Singleton, 
                    so you should not call the constructor 
                    directly, but instead call the static Singleton 
                    Factory method <c>Model.getInstance(() => new Model())</c>
                </para>
            </remarks>
            <exception cref="T:System.Exception">Thrown if instance for this Singleton key has already been constructed</exception>
        </member>
        <member name="M:PureMVC.Core.Model.InitializeModel">
            <summary>
            Initialize the Singleton <c>Model</c> instance.
            </summary>
            <remarks>
                <para>
                    Called automatically by the constructor, this 
                    is your opportunity to initialize the Singleton 
                    instance in your subclass without overriding the 
                    constructor
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Core.Model.GetInstance(System.Func{PureMVC.Interfaces.IModel})">
            <summary>
            <c>Model</c> Singleton Factory method. 
            </summary>
            <param name="modelFunc">the <c>FuncDelegate</c> of the <c>IModel</c></param>
            <returns>the instance for this Singleton key </returns>
        </member>
        <member name="M:PureMVC.Core.Model.RegisterProxy(PureMVC.Interfaces.IProxy)">
            <summary>
            Register an <c>IProxy</c> with the <c>Model</c>.
            </summary>
            <param name="proxy">proxy an <c>IProxy</c> to be held by the <c>Model</c>.</param>
        </member>
        <member name="M:PureMVC.Core.Model.RetrieveProxy(System.String)">
            <summary>
            Retrieve an <c>IProxy</c> from the <c>Model</c>.
            </summary>
            <param name="proxyName"></param>
            <returns>the <c>IProxy</c> instance previously registered with the given <c>proxyName</c>.</returns>
        </member>
        <member name="M:PureMVC.Core.Model.RemoveProxy(System.String)">
            <summary>
            Remove an <c>IProxy</c> from the <c>Model</c>.
            </summary>
            <param name="proxyName">proxyName name of the <c>IProxy</c> instance to be removed.</param>
            <returns>the <c>IProxy</c> that was removed from the <c>Model</c></returns>
        </member>
        <member name="M:PureMVC.Core.Model.HasProxy(System.String)">
            <summary>
            Check if a Proxy is registered
            </summary>
            <param name="proxyName"></param>
            <returns>whether a Proxy is currently registered with the given <c>proxyName</c>.</returns>
        </member>
        <member name="F:PureMVC.Core.Model.proxyMap">
            <summary>Mapping of proxyNames to IProxy instances</summary>
        </member>
        <member name="F:PureMVC.Core.Model.instance">
            <summary>Singleton instance</summary>
        </member>
        <member name="F:PureMVC.Core.Model.Singleton_MSG">
            <summary>Message Constants</summary>
        </member>
        <member name="T:PureMVC.Core.View">
            <summary>
            A Singleton <c>IView</c> implementation.
            </summary>
            <remarks>
                <para>In PureMVC, the <c>View</c> class assumes these responsibilities:</para>
                <list type="bullet">
                    <item>Maintain a cache of <c>IMediator</c> instances</item>
                    <item>Provide methods for registering, retrieving, and removing <c>IMediators</c></item>
                    <item>Managing the observer lists for each <c>INotification</c> in the application</item>
                    <item>Providing a method for attaching <c>IObservers</c> to an <c>INotification</c>'s observer list</item>
                    <item>Providing a method for broadcasting an <c>INotification</c></item>
                    <item>Notifying the <c>IObservers</c> of a given <c>INotification</c> when it broadcast</item>
                </list>
            </remarks>
            <seealso cref="T:PureMVC.Patterns.Mediator.Mediator"/>
            <seealso cref="T:PureMVC.Patterns.Observer.Observer"/>
            <seealso cref="T:PureMVC.Patterns.Observer.Notification"/>
        </member>
        <member name="M:PureMVC.Core.View.#ctor">
            <summary>
            Constructs and initializes a new view
            </summary>
            <remarks>
                <para>
                    This <c>IView</c> implementation is a Singleton, 
                    so you should not call the constructor 
                    directly, but instead call the static Singleton 
                    Factory method <c>View.getInstance(() => new View())</c>
                </para>
            </remarks>
            <exception cref="T:System.Exception">Thrown if Singleton instance has already been constructed</exception>
        </member>
        <member name="M:PureMVC.Core.View.InitializeView">
            <summary>
            Initialize the Singleton View instance.
            </summary>
            <remarks>
                <para>
                    Called automatically by the constructor, this
                    is your opportunity to initialize the Singleton
                    instance in your subclass without overriding the
                    constructor.
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Core.View.GetInstance(System.Func{PureMVC.Interfaces.IView})">
            <summary>
            <c>View</c> Singleton Factory method. 
            </summary>
            <param name="viewFunc">the <c>FuncDelegate</c> of the <c>IView</c></param>
            <returns>the instance for this Singleton key </returns>
        </member>
        <member name="M:PureMVC.Core.View.RegisterObserver(System.String,PureMVC.Interfaces.IObserver)">
            <summary>
                Register an <c>IObserver</c> to be notified
                of <c>INotifications</c> with a given name.
            </summary>
            <param name="notificationName">the name of the <c>INotifications</c> to notify this <c>IObserver</c> of</param>
            <param name="observer">the <c>IObserver</c> to register</param>
        </member>
        <member name="M:PureMVC.Core.View.NotifyObservers(PureMVC.Interfaces.INotification)">
            <summary>
            Notify the <c>IObservers</c> for a particular <c>INotification</c>.
            </summary>
            <remarks>
                <para>
                    All previously attached <c>IObservers</c> for this <c>INotification</c>'s
                    list are notified and are passed a reference to the <c>INotification</c> in
                    the order in which they were registered.
                </para>
            </remarks>
            <param name="notification"></param>
        </member>
        <member name="M:PureMVC.Core.View.RemoveObserver(System.String,System.Object)">
            <summary>
            Remove the observer for a given notifyContext from an observer list for a given Notification name.
            </summary>
            <param name="notificationName">which observer list to remove from </param>
            <param name="notifyContext">remove the observer with this object as its notifyContext</param>
        </member>
        <member name="M:PureMVC.Core.View.RegisterMediator(PureMVC.Interfaces.IMediator)">
            <summary>
            Register an <c>IMediator</c> instance with the <c>View</c>.
            </summary>
            <remarks>
                <para>
                    Registers the <c>IMediator</c> so that it can be retrieved by name,
                    and further interrogates the <c>IMediator</c> for its 
                    <c>INotification</c> interests.
                </para>
                <para>
                    If the <c>IMediator</c> returns any <c>INotification</c>
                    names to be notified about, an <c>Observer</c> is created encapsulating 
                    the <c>IMediator</c> instance's <c>handleNotification</c> method 
                    and registering it as an <c>Observer</c> for all <c>INotifications</c> the
                    <c>IMediator</c> is interested in.
                </para>
            </remarks>
            <param name="mediator">the name to associate with this <c>IMediator</c> instance</param>
        </member>
        <member name="M:PureMVC.Core.View.RetrieveMediator(System.String)">
            <summary>
            Retrieve an <c>IMediator</c> from the <c>View</c>.
            </summary>
            <param name="mediatorName">the name of the <c>IMediator</c> instance to retrieve.</param>
            <returns>the <c>IMediator</c> instance previously registered with the given <c>mediatorName</c>.</returns>
        </member>
        <member name="M:PureMVC.Core.View.RemoveMediator(System.String)">
            <summary>
            Remove an <c>IMediator</c> from the <c>View</c>.
            </summary>
            <param name="mediatorName">name of the <c>IMediator</c> instance to be removed.</param>
            <returns>the <c>IMediator</c> that was removed from the <c>View</c></returns>
        </member>
        <member name="M:PureMVC.Core.View.HasMediator(System.String)">
            <summary>
            Check if a Mediator is registered or not
            </summary>
            <param name="mediatorName"></param>
            <returns>whether a Mediator is registered with the given <c>mediatorName</c>.</returns>
        </member>
        <member name="F:PureMVC.Core.View.mediatorMap">
            <summary>Mapping of Mediator names to Mediator instances</summary>
        </member>
        <member name="F:PureMVC.Core.View.observerMap">
            <summary>Mapping of Notification names to Observer lists</summary>
        </member>
        <member name="F:PureMVC.Core.View.instance">
            <summary>Singleton instance</summary>
        </member>
        <member name="F:PureMVC.Core.View.Singleton_MSG">
            <summary>Message Constants</summary>
        </member>
        <member name="T:PureMVC.Interfaces.ICommand">
            <summary>
            The interface definition for a PureMVC Command.
            </summary>
            <seealso cref="T:PureMVC.Interfaces.INotification"/>
        </member>
        <member name="M:PureMVC.Interfaces.ICommand.Execute(PureMVC.Interfaces.INotification)">
            <summary>
            Execute the <c>ICommand</c>'s logic to handle a given <c>INotification</c>.
            </summary>
            <param name="Notification">an <c>INotification</c> to handle.</param>
        </member>
        <member name="T:PureMVC.Interfaces.IController">
            <summary>
            The interface definition for a PureMVC Controller.
            </summary>
            <remarks>
                <para>
                    In PureMVC, an <c>IController</c> implementor 
                    follows the 'Command and Controller' strategy, and 
                    assumes these responsibilities:
                    <list type="bullet">
                        <item>Remembering which <c>ICommand</c>s 
                        are intended to handle which <c>INotifications</c>.
                        </item>
                        <item>Registering itself as an <c>IObserver</c> with
                        the <c>View</c> for each <c>INotification</c> 
                        that it has an <c>ICommand</c> mapping for.
                        </item>
                        <item>Creating a new instance of the proper <c>ICommand</c> 
                        to handle a given <c>INotification</c> when notified by the <c>View</c>.
                        </item>
                        <item>Calling the <c>ICommand</c>'s <c>execute</c> 
                        method, passing in the <c>INotification</c>.
                        </item>
                    </list>
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Interfaces.INotification"/>
            <seealso cref="T:PureMVC.Interfaces.ICommand"/>
        </member>
        <member name="M:PureMVC.Interfaces.IController.RegisterCommand(System.String,System.Func{PureMVC.Interfaces.ICommand})">
            <summary>
            Register a particular <c>ICommand</c> class as the handler 
             for a particular <c>INotification</c>.
            </summary>
            <param name="notificationName">the name of the <c>INotification</c></param>
            <param name="commandClassRef">the FuncDelegate of the <c>ICommand</c></param>
        </member>
        <member name="M:PureMVC.Interfaces.IController.ExecuteCommand(PureMVC.Interfaces.INotification)">
            <summary>
            Execute the <c>ICommand</c> previously registered as the
            handler for <c>INotification</c>s with the given notification name.
            </summary>
            <param name="notification">the <c>INotification</c> to execute the associated <c>ICommand</c> for</param>
        </member>
        <member name="M:PureMVC.Interfaces.IController.RemoveCommand(System.String)">
            <summary>
            Remove a previously registered <c>ICommand</c> to <c>INotification</c> mapping.
            </summary>
            <param name="notificationName">the name of the <c>INotification</c> to remove the <c>ICommand</c> mapping for</param>
        </member>
        <member name="M:PureMVC.Interfaces.IController.HasCommand(System.String)">
            <summary>
            Check if a Command is registered for a given Notification 
            </summary>
            <param name="notificationName">whether a Command is currently registered for the given <c>notificationName</c>.</param>
            <returns></returns>
        </member>
        <member name="T:PureMVC.Interfaces.IFacade">
            <summary>
            The interface definition for a PureMVC Facade.
            </summary>
            <remarks>
                <para>
                    The Facade Pattern suggests providing a single
                    class to act as a central point of communication 
                    for a subsystem.
                </para>
                <para>
                    In PureMVC, the Facade acts as an interface between
                    the core MVC actors (Model, View, Controller) and
                    the rest of your application.
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Interfaces.IModel"/>
            <seealso cref="T:PureMVC.Interfaces.IView"/>
            <seealso cref="T:PureMVC.Interfaces.IController"/>
            <seealso cref="T:PureMVC.Interfaces.ICommand"/>
            <seealso cref="T:PureMVC.Interfaces.INotification"/>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.RegisterProxy(PureMVC.Interfaces.IProxy)">
            <summary>
            Register an <c>IProxy</c> with the <c>Model</c> by name.
            </summary>
            <param name="proxy">the <c>IProxy</c> to be registered with the <c>Model</c>.</param>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.RetrieveProxy(System.String)">
            <summary>
            Retrieve a <c>IProxy</c> from the <c>Model</c> by name.
            </summary>
            <param name="proxyName">the name of the <c>IProxy</c> instance to be retrieved.</param>
            <returns>the <c>IProxy</c> previously regisetered by <c>proxyName</c> with the <c>Model</c>.</returns>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.RemoveProxy(System.String)">
            <summary>
            Remove an <c>IProxy</c> instance from the <c>Model</c> by name.
            </summary>
            <param name="proxyName">the <c>IProxy</c> to remove from the <c>Model</c>.</param>
            <returns>the <c>IProxy</c> that was removed from the <c>Model</c></returns>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.HasProxy(System.String)">
            <summary>
            Check if a Proxy is registered
            </summary>
            <param name="proxyName"></param>
            <returns>whether a Proxy is currently registered with the given <c>proxyName</c>.</returns>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.RegisterCommand(System.String,System.Func{PureMVC.Interfaces.ICommand})">
            <summary>
            Register an <c>ICommand</c> with the <c>Controller</c>.
            </summary>
            <param name="notificationName">the name of the <c>INotification</c> to associate the <c>ICommand</c> with.</param>
            <param name="commandClassRef">a reference to the <c>FuncDelegate</c> of the <c>ICommand</c></param>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.RemoveCommand(System.String)">
            <summary>
            Remove a previously registered <c>ICommand</c> to <c>INotification</c> mapping from the Controller.
            </summary>
            <param name="notificationName">the name of the <c>INotification</c> to remove the <c>ICommand</c> mapping for</param>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.HasCommand(System.String)">
            <summary>
            Check if a Command is registered for a given Notification 
            </summary>
            <param name="notificationName"></param>
            <returns>whether a Command is currently registered for the given <c>notificationName</c>.</returns>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.RegisterMediator(PureMVC.Interfaces.IMediator)">
            <summary>
            Register an <c>IMediator</c> instance with the <c>View</c>.
            </summary>
            <param name="mediator">a reference to the <c>IMediator</c> instance</param>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.RetrieveMediator(System.String)">
            <summary>
            Retrieve an <c>IMediator</c> instance from the <c>View</c>.
            </summary>
            <param name="mediatorName">the name of the <c>IMediator</c> instance to retrievve</param>
            <returns>the <c>IMediator</c> previously registered with the given <c>mediatorName</c>.</returns>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.RemoveMediator(System.String)">
            <summary>
            Remove a <c>IMediator</c> instance from the <c>View</c>.
            </summary>
            <param name="mediatorName">name of the <c>IMediator</c> instance to be removed</param>
            <returns>the <c>IMediator</c> instance previously registered with the given <c>mediatorName</c>.</returns>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.HasMediator(System.String)">
            <summary>
            Check if a Mediator is registered or not
            </summary>
            <param name="mediatorName"></param>
            <returns>whether a Mediator is registered with the given <c>mediatorName</c>.</returns>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.NotifyObservers(PureMVC.Interfaces.INotification)">
            <summary>
            Notify <c>Observer</c>s.
            </summary>
            <remarks>
                <para>
                    This method is left public mostly for backward 
                    compatibility, and to allow you to send custom 
                    notification classes using the facade.
                </para>
                <para>
                    Usually you should just call sendNotification
                    and pass the parameters, never having to 
                    construct the notification yourself.
                </para>
            </remarks>
            <param name="notification">the <c>INotification</c> to have the <c>View</c> notify <c>Observers</c> of.</param>
        </member>
        <member name="T:PureMVC.Interfaces.IMediator">
            <summary>
            The interface definition for a PureMVC Mediator.
            </summary>
            <remarks>
                <para>
                    In PureMVC, <c>IMediator</c> implementors assume these responsibilities:
                    <list type="bullet">
                        <item>Implement a common method which returns a list of all <c>INotification</c>s
                        the <c>IMediator</c> has interest in.</item>
                        <item>Implement a notification callback method.</item>
                        <item>Implement methods that are called when the IMediator is registered or removed from the View</item>
                    </list>
                </para>
                <para>
                    Additionally, <c>IMediator</c>s typically:
                    <list type="bullet">
                        <item>Act as an intermediary between one or more view components such as text boxes or 
                        list controls, maintaining references and coordinating their behavior.</item>
                        <item>In Flash-based apps, this is often the place where event listeners are
                        added to view components, and their handlers implemented.</item>
                        <item>Respond to and generate <c>INotifications</c>, interacting with of
                        the rest of the PureMVC app.</item>
                    </list>
                </para>
                <para>
                    When an <c>IMediator</c> is registered with the <c>IView</c>, 
                    the <c>IView</c> will call the <c>IMediator</c>'s 
                    <c>listNotificationInterests</c> method. The <c>IMediator</c> will 
                    return an <c>Array</c> of <c>INotification</c> names which 
                    it wishes to be notified about.
                </para>
                <para>
                    The <c>IView</c> will then create an <c>Observer</c> object 
                    encapsulating that <c>IMediator</c>'s (<c>handleNotification</c>) method
                    and register it as an Observer for each <c>INotification</c> name returned by 
                    <c>listNotificationInterests</c>.
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Interfaces.INotification"/>
        </member>
        <member name="P:PureMVC.Interfaces.IMediator.MediatorName">
            <summary>
            Get or Set the <c>IMediator</c> instance name
            </summary>
        </member>
        <member name="P:PureMVC.Interfaces.IMediator.ViewComponent">
            <summary>
            Get or Set the <c>IMediator</c>'s view component.
            </summary>
        </member>
        <member name="M:PureMVC.Interfaces.IMediator.ListNotificationInterests">
            <summary>
            List <c>INotification</c> interests.
            </summary>
            <returns> an <c>Array</c> of the <c>INotification</c> names this <c>IMediator</c> has an interest in.</returns>
        </member>
        <member name="M:PureMVC.Interfaces.IMediator.HandleNotification(PureMVC.Interfaces.INotification)">
            <summary>
            Handle an <c>INotification</c>.
            </summary>
            <param name="notification">notification the <c>INotification</c> to be handled</param>
        </member>
        <member name="M:PureMVC.Interfaces.IMediator.OnRegister">
            <summary>
            Called by the View when the Mediator is registered
            </summary>
        </member>
        <member name="M:PureMVC.Interfaces.IMediator.OnRemove">
            <summary>
            Called by the View when the Mediator is removed
            </summary>
        </member>
        <member name="T:PureMVC.Interfaces.IModel">
            <summary>
            The interface definition for a PureMVC Model.
            </summary>
            <remarks>
                <para>
                    In PureMVC, <c>IModel</c> implementors provide
                    access to <c>IProxy</c> objects by named lookup.
                </para>
                <para>
                    An <c>IModel</c> assumes these responsibilities:
                    <list type="bullet">
                        <item>Maintain a cache of <c>IProxy</c> instances</item>
                        <item>Provide methods for registering, retrieving, and removing <c>IProxy</c> instances</item>
                    </list>
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Interfaces.IModel.RegisterProxy(PureMVC.Interfaces.IProxy)">
            <summary>
            Register an <c>IProxy</c> instance with the <c>Model</c>.
            </summary>
            <param name="proxy">an object reference to be held by the <c>Model</c>.</param>
        </member>
        <member name="M:PureMVC.Interfaces.IModel.RetrieveProxy(System.String)">
            <summary>
            Retrieve an <c>IProxy</c> instance from the Model.
            </summary>
            <param name="proxyName"></param>
            <returns>the <c>IProxy</c> instance previously registered with the given <c>proxyName</c>.</returns>
        </member>
        <member name="M:PureMVC.Interfaces.IModel.RemoveProxy(System.String)">
            <summary>
            Remove an <c>IProxy</c> instance from the Model.
            </summary>
            <param name="proxyName"></param>
            <returns>the <c>IProxy</c> that was removed from the <c>Model</c></returns>
        </member>
        <member name="M:PureMVC.Interfaces.IModel.HasProxy(System.String)">
            <summary>
            Check if a Proxy is registered
            </summary>
            <param name="proxyName"></param>
            <returns>whether a Proxy is currently registered with the given <c>proxyName</c>.</returns>
        </member>
        <member name="T:PureMVC.Interfaces.INotification">
            <summary>
            A base <c>INotification</c> implementation.
            </summary>
            <remarks>
                <para>
                    PureMVC does not rely upon underlying event models such 
                    as the one provided with Flash, and ActionScript 3 does 
                    not have an inherent event model.
                </para>
                <para>
                    The Observer Pattern as implemented within PureMVC exists 
                    to support event-driven communication between the 
                    application and the actors of the MVC triad.
                </para>
                <para>
                    Notifications are not meant to be a replacement for Events
                    in Flex/Flash/Apollo. Generally, <c>IMediator</c> implementors
                    place event listeners on their view components, which they
                    then handle in the usual way. This may lead to the broadcast of <c>Notification</c>s to 
                    trigger <c>ICommand</c>s or to communicate with other <c>IMediators</c>. 
                    <c>IProxy</c> and <c>ICommand</c>
                    instances communicate with each other and <c>IMediator</c>s
                    by broadcasting <c>INotification</c>s.
                </para>
                <para>
                    A key difference between Flash <c>Event</c>s and PureMVC
                    <c>Notification</c>s is that <c>Event</c>s follow the 
                    'Chain of Responsibility' pattern, 'bubbling' up the display hierarchy 
                    until some parent component handles the <c>Event</c>, while
                    PureMVC <c>Notification</c>s follow a 'Publish/Subscribe'
                    pattern. PureMVC classes need not be related to each other in a 
                    parent/child relationship in order to communicate with one another
                    using <c>Notification</c>s.
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Interfaces.IView"/>
            <seealso cref="T:PureMVC.Interfaces.IObserver"/>
        </member>
        <member name="P:PureMVC.Interfaces.INotification.Name">
            <summary>
            Get the name of the <c>INotification</c> instance. 
            No setter, should be set by constructor only
            </summary>
        </member>
        <member name="P:PureMVC.Interfaces.INotification.Body">
            <summary>
            Get or Set the body of the <c>INotification</c> instance
            </summary>
        </member>
        <member name="P:PureMVC.Interfaces.INotification.Type">
            <summary>
            Get or Set the type of the <c>INotification</c> instance
            </summary>
        </member>
        <member name="M:PureMVC.Interfaces.INotification.ToString">
            <summary>
            Get the string representation of the <c>INotification</c> instance
            </summary>
            <returns>String representation</returns>
        </member>
        <member name="T:PureMVC.Interfaces.INotifier">
            <summary>
            A Base <c>INotifier</c> implementation.
            </summary>
            <remarks>
                <para>
                    <c>MacroCommand, Command, Mediator</c> and <c>Proxy</c> 
                    all have a need to send <c>Notifications</c>.
                </para>
                <para>
                    The <c>INotifier</c> interface provides a common method called
                    <c>sendNotification</c> that relieves implementation code of 
                    the necessity to actually construct <c>Notifications</c>.
                </para>
                <para>
                    The <c>Notifier</c> class, which all of the above mentioned classes
                    extend, provides an initialized reference to the <c>Facade</c>
                    Multiton, which is required for the convienience method
                    for sending <c>Notifications</c>, but also eases implementation as these
                    classes have frequent <c>Facade</c> interactions and usually require
                    access to the facade anyway.
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Interfaces.IFacade"/>
            <seealso cref="T:PureMVC.Interfaces.INotification"/>
        </member>
        <member name="M:PureMVC.Interfaces.INotifier.SendNotification(System.String,System.Object,System.String)">
            <summary>
            Send a <c>INotification</c>.
            </summary>
            <remarks>
                <para>
                    Convenience method to prevent having to construct new 
                    notification instances in our implementation code.
                </para>
            </remarks>
            <param name="notificationName">the name of the notification to send</param>
            <param name="body">the body of the notification (optional)</param>
            <param name="type">the type of the notification (optional)</param>
        </member>
        <member name="T:PureMVC.Interfaces.IObserver">
            <summary>
            The interface definition for a PureMVC Observer.
            </summary>
            <remarks>
                <para>
                    In PureMVC, the <c>Observer</c> class assumes these responsibilities:
                    <list type="bullet">
                        <item>Encapsulate the notification (callback) method of the interested object.</item>
                        <item>Encapsulate the notification context (this) of the interested object.</item>
                        <item>Provide methods for setting the notification method and context.</item>
                        <item>Provide a method for notifying the interested object.</item>
                    </list>
                </para>
                <para>
                    PureMVC does not rely upon underlying event models such 
                    as the one provided with Flash, and ActionScript 3 does 
                    not have an inherent event model.
                </para>
                <para>
                    The Observer Pattern as implemented within PureMVC exists 
                    to support event-driven communication between the 
                    application and the actors of the MVC triad.
                </para>
                <para>
                    An Observer is an object that encapsulates information
                    about an interested object with a notification method that
                    should be called when an <c>INotification</c> is broadcast. The Observer then
                    acts as a proxy for notifying the interested object.
                </para>
                <para>
                    Observers can receive <c>Notification</c>s by having their
                    <c>notifyObserver</c> method invoked, passing
                    in an object implementing the <c>INotification</c> interface, such
                    as a subclass of <c>Notification</c>.
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Interfaces.IView"/>
            <seealso cref="T:PureMVC.Interfaces.INotification"/>
        </member>
        <member name="P:PureMVC.Interfaces.IObserver.NotifyMethod">
            <summary>
            Set the notification method (callback) method of the interested object
            </summary>
            <remarks>
                <para>
                    The notification method should take one parameter of type <c>INotification</c>
                </para>
            </remarks>
        </member>
        <member name="P:PureMVC.Interfaces.IObserver.NotifyContext">
            <summary>
            Set the notification context (this) of the interested object
            </summary>
        </member>
        <member name="M:PureMVC.Interfaces.IObserver.NotifyObserver(PureMVC.Interfaces.INotification)">
            <summary>
            Notify the interested object.
            </summary>
            <param name="notification">the <c>INotification</c> to pass to the interested object's notification method</param>
        </member>
        <member name="M:PureMVC.Interfaces.IObserver.CompareNotifyContext(System.Object)">
            <summary>
            Compare the given object to the notificaiton context object.
            </summary>
            <param name="obj">the object to compare.</param>
            <returns>indicating if the notification context and the object are the same.</returns>
        </member>
        <member name="T:PureMVC.Interfaces.IProxy">
            <summary>
            The interface definition for a PureMVC Proxy.
            </summary>
            <remarks>
                <para>
                    In PureMVC, <c>IProxy</c> implementors assume these responsibilities:
                    <list type="bullet">
                        <item>Implement a common method which returns the name of the Proxy.</item>
                        <item>Provide methods for setting and getting the data object.</item>
                    </list>
                </para>
                <para>
                    Additionally, <c>IProxy</c>s typically:
                    <list type="bullet">
                        <item>Maintain references to one or more pieces of model data.</item>
                        <item>Provide methods for manipulating that data.</item>
                        <item>Generate <c>INotifications</c> when their model data changes.</item>
                        <item>Expose their name as a <c>public static const</c> called <c>NAME</c>, if they are not instantiated multiple times.</item>
                        <item>Encapsulate interaction with local or remote services used to fetch and persist model data.</item>
                    </list>
                </para>
            </remarks>
        </member>
        <member name="P:PureMVC.Interfaces.IProxy.ProxyName">
            <summary>
            Get the Proxy name
            </summary>
        </member>
        <member name="P:PureMVC.Interfaces.IProxy.Data">
            <summary>
            Get or Set the data object
            </summary>
        </member>
        <member name="M:PureMVC.Interfaces.IProxy.OnRegister">
            <summary>
            Called by the Model when the Proxy is registered
            </summary>
        </member>
        <member name="M:PureMVC.Interfaces.IProxy.OnRemove">
            <summary>
            Called by the Model when the Proxy is removed
            </summary>
        </member>
        <member name="T:PureMVC.Interfaces.IView">
            <summary>
            The interface definition for a PureMVC View.
            </summary>
            <remarks>
                <para>In PureMVC, the <c>View</c> class assumes these responsibilities:</para>
                <list type="bullet">
                    <item>Maintain a cache of <c>IMediator</c> instances</item>
                    <item>Provide methods for registering, retrieving, and removing <c>IMediators</c></item>
                    <item>Managing the observer lists for each <c>INotification</c> in the application</item>
                    <item>Providing a method for attaching <c>IObservers</c> to an <c>INotification</c>'s observer list</item>
                    <item>Providing a method for broadcasting an <c>INotification</c></item>
                    <item>Notifying the <c>IObservers</c> of a given <c>INotification</c> when it broadcast</item>
                </list>
            </remarks>
            <seealso cref="T:PureMVC.Interfaces.IMediator"/>
            <seealso cref="T:PureMVC.Interfaces.IObserver"/>
            <seealso cref="T:PureMVC.Interfaces.INotification"/>
        </member>
        <member name="M:PureMVC.Interfaces.IView.RegisterObserver(System.String,PureMVC.Interfaces.IObserver)">
            <summary>
            Register an <c>IObserver</c> to be notified
            of <c>INotifications</c> with a given name.
            </summary>
            <param name="notificationName">the name of the <c>INotifications</c> to notify this <c>IObserver</c> of</param>
            <param name="observer">the <c>IObserver</c> to register</param>
        </member>
        <member name="M:PureMVC.Interfaces.IView.RemoveObserver(System.String,System.Object)">
            <summary>
            Remove a group of observers from the observer list for a given Notification name.
            </summary>
            <param name="notificationName">which observer list to remove from </param>
            <param name="notifyContext">removed the observers with this object as their notifyContext</param>
        </member>
        <member name="M:PureMVC.Interfaces.IView.NotifyObservers(PureMVC.Interfaces.INotification)">
            <summary>
            Notify the <c>IObservers</c> for a particular <c>INotification</c>.
            </summary>
            <remarks>
                <para>
                    All previously attached <c>IObservers</c> for this <c>INotification</c>'s
                    list are notified and are passed a reference to the <c>INotification</c> in 
                    the order in which they were registered.
                </para>
            </remarks>
            <param name="notification">the <c>INotification</c> to notify <c>IObservers</c> of.</param>
        </member>
        <member name="M:PureMVC.Interfaces.IView.RegisterMediator(PureMVC.Interfaces.IMediator)">
            <summary>
            Register an <c>IMediator</c> instance with the <c>View</c>.
            </summary>
            <remarks>
                <para>
                    Registers the <c>IMediator</c> so that it can be retrieved by name,
                    and further interrogates the <c>IMediator</c> for its 
                    <c>INotification</c> interests.
                </para>
                <para>
                    If the <c>IMediator</c> returns any <c>INotification</c> 
                    names to be notified about, an <c>Observer</c> is created encapsulating 
                    the <c>IMediator</c> instance's <c>handleNotification</c> method 
                    and registering it as an <c>Observer</c> for all <c>INotifications</c> the 
                    <c>IMediator</c> is interested in.
                </para>
            </remarks>
            <param name="mediator">a reference to the <c>IMediator</c> instance</param>
        </member>
        <member name="M:PureMVC.Interfaces.IView.RetrieveMediator(System.String)">
            <summary>
            Retrieve an <c>IMediator</c> from the <c>View</c>.
            </summary>
            <param name="mediatorName">the name of the <c>IMediator</c> instance to retrieve.</param>
            <returns>the <c>IMediator</c> instance previously registered with the given <c>mediatorName</c>.</returns>
        </member>
        <member name="M:PureMVC.Interfaces.IView.RemoveMediator(System.String)">
            <summary>
            Remove an <c>IMediator</c> from the <c>View</c>.
            </summary>
            <param name="mediatorName">name of the <c>IMediator</c> instance to be removed.</param>
            <returns>the <c>IMediator</c> that was removed from the <c>View</c></returns>
        </member>
        <member name="M:PureMVC.Interfaces.IView.HasMediator(System.String)">
            <summary>
            Check if a Mediator is registered or not
            </summary>
            <param name="mediatorName"></param>
            <returns>whether a Mediator is registered with the given <c>mediatorName</c>.</returns>
        </member>
        <member name="T:PureMVC.Patterns.Command.MacroCommand">
            <summary>
            A base <c>ICommand</c> implementation that executes other <c>ICommand</c>s.
            </summary>
            <remarks>
                <para>
                    A <c>MacroCommand</c> maintains an list of
                    <c>ICommand</c> Class references called <i>SubCommands</i>.
                </para>
                <para>
                    When <c>execute</c> is called, the <c>MacroCommand</c> 
                    instantiates and calls <c>execute</c> on each of its <i>SubCommands</i> turn.
                    Each <i>SubCommand</i> will be passed a reference to the original
                    <c>INotification</c> that was passed to the <c>MacroCommand</c>'s 
                    <c>execute</c> method.
                </para>
                <para>
                    Unlike <c>SimpleCommand</c>, your subclass
                    should not override <c>execute</c>, but instead, should 
                    override the <c>initializeMacroCommand</c> method, 
                    calling <c>addSubCommand</c> once for each <i>SubCommand</i>
                    to be executed.
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Core.Controller"/>
            <seealso cref="T:PureMVC.Patterns.Observer.Notification"/>
            <seealso cref="T:PureMVC.Patterns.Command.SimpleCommand"/>
        </member>
        <member name="M:PureMVC.Patterns.Command.MacroCommand.#ctor">
            <summary>
            Constructor.
            </summary>
            <remarks>
                <para>
                    You should not need to define a constructor, 
                    instead, override the <c>initializeMacroCommand</c>
                    method.
                </para>
                <para>
                    If your subclass does define a constructor, be 
                    sure to call <c>super()</c>.
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Patterns.Command.MacroCommand.InitializeMacroCommand">
            <summary>
            Initialize the <c>MacroCommand</c>.
            </summary>
            <remarks>
                <para>
                    In your subclass, override this method to 
                    initialize the <c>MacroCommand</c>'s <i>SubCommand</i>  
                    list with <c>ICommand</c> class references like
                    this:
                </para>
                <example>
                    <code>
                        override void InitializeMacroCommand() 
                        {
                            AddSubCommand(() => new com.me.myapp.controller.FirstCommand());
                            AddSubCommand(() => new com.me.myapp.controller.SecondCommand());
                            AddSubCommand(() => new com.me.myapp.controller.ThirdCommand());
                        }
                    </code>
                </example>
                <para>
                    Note that <i>SubCommand</i>s may be any <c>ICommand</c> implementor,
                    <c>MacroCommand</c>s or <c>SimpleCommands</c> are both acceptable.
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Patterns.Command.MacroCommand.AddSubCommand(System.Func{PureMVC.Interfaces.ICommand})">
            <summary>
            Add a <c>SubCommand</c>.
            </summary>
            <remarks>
                <para>
                    The <i>SubCommands</i> will be called in First In/First Out (FIFO)
                    order.
                </para>
            </remarks>
            <param name="commandFunc">a reference to the <c>FuncDelegate</c> of the <c>ICommand</c>.</param>
        </member>
        <member name="M:PureMVC.Patterns.Command.MacroCommand.Execute(PureMVC.Interfaces.INotification)">
            <summary>
            Execute this <c>MacroCommand</c>'s <i>SubCommands</i>.
            </summary>
            <remarks>
                <para>
                    The <i>SubCommands</i> will be called in First In/First Out (FIFO)
                    order.
                </para>
            </remarks>
            <param name="notification">the <c>INotification</c> object to be passsed to each <i>SubCommand</i>.</param>
        </member>
        <member name="F:PureMVC.Patterns.Command.MacroCommand.subcommands">
            <summary>List of subcommands</summary>
        </member>
        <member name="T:PureMVC.Patterns.Command.SimpleCommand">
            <summary>
            A base <c>ICommand</c> implementation.
            </summary>
            <remarks>
                <para>
                    Your subclass should override the <c>execute</c> 
                    method where your business logic will handle the <c>INotification</c>. 
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Core.Controller"/>
            <seealso cref="T:PureMVC.Patterns.Observer.Notification"/>
            <seealso cref="T:PureMVC.Patterns.Command.MacroCommand"/>
        </member>
        <member name="M:PureMVC.Patterns.Command.SimpleCommand.Execute(PureMVC.Interfaces.INotification)">
            <summary>
            Fulfill the use-case initiated by the given <c>INotification</c>.
            </summary>
            <remarks>
                <para>
                    In the Command Pattern, an application use-case typically
                    begins with some user action, which results in an <c>INotification</c> being broadcast, which 
                    is handled by business logic in the <c>execute</c> method of an
                    <c>ICommand</c>.
                </para>
            </remarks>
            <param name="notification">the <c>INotification</c> to handle.</param>
        </member>
        <member name="T:PureMVC.Patterns.Facade.Facade">
            <summary>
            A base Singleton <c>IFacade</c> implementation.
            </summary>
            <remarks>
                <para>
                    In PureMVC, the <c>Facade</c> class assumes these 
                    responsibilities:
                </para>
                <list type="bullet">
                    <item>Initializing the <c>Model</c>, <c>View</c> and <c>Controller</c> Singletons.</item>
                    <item>Providing all the methods defined by the <c>IModel, IView, and IController</c> interfaces.</item>
                    <item>Providing the ability to override the specific <c>Model</c>, <c>View</c> and <c>Controller</c> Singletons created.</item>
                    <item>Providing a single point of contact to the application for registering <c>Commands</c> and notifying <c>Observers</c></item>
                </list>
            </remarks>
            <seealso cref="T:PureMVC.Core.Model"/>
            <seealso cref="T:PureMVC.Core.View"/>
            <seealso cref="T:PureMVC.Core.Controller"/>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.#ctor">
            <summary>
            Constructor.
            </summary>
            <remarks>
                <para>
                    This <c>IFacade</c> implementation is a Singleton, 
                    so you should not call the constructor 
                    directly, but instead call the static Factory method, 
                    passing the unique key for this instance 
                    <c>Facade.getInstance(() => new Facade())</c>
                </para>
            </remarks>
            <exception cref="T:System.Exception">Thrown if instance for this Singleton key has already been constructed</exception>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.InitializeFacade">
            <summary>
            Initialize the Singleton <c>Facade</c> instance.
            </summary>
            <remarks>
                <para>
                    Called automatically by the constructor. Override in your
                    subclass to do any subclass specific initializations. Be
                    sure to call <c>super.initializeFacade()</c>, though.
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.GetInstance(System.Func{PureMVC.Interfaces.IFacade})">
            <summary>
            Facade Singleton Factory method
            </summary>
            <param name="facadeFunc">the <c>FuncDelegate</c> of the <c>IFacade</c></param>
            <returns>the Singleton instance of the Facade</returns>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.InitializeController">
            <summary>
            Initialize the <c>Controller</c>.
            </summary>
            <remarks>
                <para>
                    Called by the <c>initializeFacade</c> method.
                    Override this method in your subclass of <c>Facade</c> 
                    if one or both of the following are true:
                    <list type="bullet">
                        <item>You wish to initialize a different <c>IController</c>.</item>
                        <item>You have <c>Commands</c> to register with the <c>Controller</c> at startup.</item>
                    </list>
                </para>
                <para>
                    If you don't want to initialize a different <c>IController</c>, 
                    call <c>super.initializeController()</c> at the beginning of your
                    method, then register <c>Command</c>s.
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.InitializeModel">
            <summary>
            Initialize the <c>Model</c>.
            </summary>
            <remarks>
                <para>
                    Called by the <c>initializeFacade</c> method.
                    Override this method in your subclass of <c>Facade</c> 
                    if one or both of the following are true:
                    <list type="bullet">
                        <item>You wish to initialize a different <c>IModel</c>.</item>
                        <item>You have <c>Proxy</c>s to register with the <c>Model</c> that do not
                            retrieve a reference to the Facade at construction time.
                        </item>
                    </list>
                </para>
                <para>
                    If you don't want to initialize a different <c>IModel</c>, 
                    call <c>super.initializeModel()</c> at the beginning of your
                    method, then register <c>Proxy</c>s.
                </para>
                <para>
                    Note: This method is <i>rarely</i> overridden; in practice you are more
                    likely to use a <c>Command</c> to create and register <c>Proxy</c>s
                    with the <c>Model</c>, since <c>Proxy</c>s with mutable data will likely
                    need to send <c>INotification</c>s and thus will likely want to fetch a reference to 
                    the <c>Facade</c> during their construction. 
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.InitializeView">
            <summary>
            Initialize the <c>View</c>.
            </summary>
            <remarks>
                <para>
                    Called by the <c>initializeFacade</c> method.
                    Override this method in your subclass of <c>Facade</c> 
                    if one or both of the following are true:
                    <list type="bullet">
                        <item>You wish to initialize a different <c>IView</c>.</item>
                        <item>You have <c>Observers</c> to register with the <c>View</c></item>
                    </list>
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.RegisterCommand(System.String,System.Func{PureMVC.Interfaces.ICommand})">
            <summary>
            Register an <c>ICommand</c> with the <c>Controller</c> by Notification name.
            </summary>
            <param name="notificationName">the name of the <c>INotification</c> to associate the <c>ICommand</c> with</param>
            <param name="commandFunc">a reference to the Class of the <c>ICommand</c></param>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.RemoveCommand(System.String)">
            <summary>
            Remove a previously registered <c>ICommand</c> to <c>INotification</c> mapping from the Controller.
            </summary>
            <param name="notificationName">the name of the <c>INotification</c> to remove the <c>ICommand</c> mapping for</param>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.HasCommand(System.String)">
            <summary>
            Check if a Command is registered for a given Notification 
            </summary>
            <param name="notificationName"></param>
            <returns>whether a Command is currently registered for the given <c>notificationName</c>.</returns>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.RegisterProxy(PureMVC.Interfaces.IProxy)">
            <summary>
            Register an <c>IProxy</c> with the <c>Model</c> by name.
            </summary>
            <param name="proxy">the <c>IProxy</c> instance to be registered with the <c>Model</c>.</param>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.RetrieveProxy(System.String)">
            <summary>
            Retrieve an <c>IProxy</c> from the <c>Model</c> by name.
            </summary>
            <param name="proxyName">the name of the proxy to be retrieved.</param>
            <returns>the <c>IProxy</c> instance previously registered with the given <c>proxyName</c>.</returns>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.RemoveProxy(System.String)">
            <summary>
            Remove an <c>IProxy</c> from the <c>Model</c> by name.
            </summary>
            <param name="proxyName">the <c>IProxy</c> to remove from the <c>Model</c>.</param>
            <returns>the <c>IProxy</c> that was removed from the <c>Model</c></returns>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.HasProxy(System.String)">
            <summary>
            Check if a Proxy is registered
            </summary>
            <param name="proxyName"></param>
            <returns>whether a Proxy is currently registered with the given <c>proxyName</c>.</returns>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.RegisterMediator(PureMVC.Interfaces.IMediator)">
            <summary>
            Register a <c>IMediator</c> with the <c>View</c>.
            </summary>
            <param name="mediator">a reference to the <c>IMediator</c></param>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.RetrieveMediator(System.String)">
            <summary>
            Retrieve an <c>IMediator</c> from the <c>View</c>.
            </summary>
            <param name="mediatorName"></param>
            <returns>the <c>IMediator</c> previously registered with the given <c>mediatorName</c>.</returns>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.RemoveMediator(System.String)">
            <summary>
            Remove an <c>IMediator</c> from the <c>View</c>.
            </summary>
            <param name="mediatorName">name of the <c>IMediator</c> to be removed.</param>
            <returns>the <c>IMediator</c> that was removed from the <c>View</c></returns>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.HasMediator(System.String)">
            <summary>
            Check if a Mediator is registered or not
            </summary>
            <param name="mediatorName"></param>
            <returns>whether a Mediator is registered with the given <c>mediatorName</c>.</returns>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.SendNotification(System.String,System.Object,System.String)">
            <summary>
            Create and send an <c>INotification</c>.
            </summary>
            <remarks>
                <para>
                    Keeps us from having to construct new notification 
                    instances in our implementation code.
                </para>
            </remarks>
            <param name="notificationName">the name of the notiification to send</param>
            <param name="body">the body of the notification (optional)</param>
            <param name="type">type the type of the notification (optional)</param>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.NotifyObservers(PureMVC.Interfaces.INotification)">
            <summary>
            Notify <c>Observer</c>s.
            </summary>
            <remarks>
                <para>
                    This method is left public mostly for backward 
                    compatibility, and to allow you to send custom 
                    notification classes using the facade.
                </para>
                <para>
                    Usually you should just call sendNotification
                    and pass the parameters, never having to 
                    construct the notification yourself.
                </para>
            </remarks>
            <param name="notification">the <c>INotification</c> to have the <c>View</c> notify <c>Observers</c> of.</param>
        </member>
        <member name="F:PureMVC.Patterns.Facade.Facade.controller">
            <summary>References to Controller</summary>
        </member>
        <member name="F:PureMVC.Patterns.Facade.Facade.model">
            <summary>Reference to Model</summary>
        </member>
        <member name="F:PureMVC.Patterns.Facade.Facade.view">
            <summary>References to View</summary>
        </member>
        <member name="F:PureMVC.Patterns.Facade.Facade.instance">
            <summary>Singleton instance</summary>
        </member>
        <member name="F:PureMVC.Patterns.Facade.Facade.Singleton_MSG">
            <summary>Message Constants</summary>
        </member>
        <member name="T:PureMVC.Patterns.Mediator.Mediator">
            <summary>
            A base <c>IMediator</c> implementation. 
            </summary>
            <seealso cref="T:PureMVC.Core.View"/>
        </member>
        <member name="F:PureMVC.Patterns.Mediator.Mediator.NAME">
            <summary>
            The name of the <c>Mediator</c>. 
            </summary>
            <remarks>
                <para>
                    Typically, a <c>Mediator</c> will be written to serve
                    one specific control or group controls and so,
                    will not have a need to be dynamically named.
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Patterns.Mediator.Mediator.#ctor(System.String,System.Object)">
            <summary>
            Constructor.
            </summary>
            <param name="mediatorName"></param>
            <param name="viewComponent"></param>
        </member>
        <member name="M:PureMVC.Patterns.Mediator.Mediator.ListNotificationInterests">
            <summary>
            List the <c>INotification</c> names this
            <c>Mediator</c> is interested in being notified of.
            </summary>
            <returns>the list of <c>INotification</c> names</returns>
        </member>
        <member name="M:PureMVC.Patterns.Mediator.Mediator.HandleNotification(PureMVC.Interfaces.INotification)">
            <summary>
            Handle <c>INotification</c>s.
            </summary>
            <remarks>
                <para>
                    Typically this will be handled in a switch statement,
                    with one 'case' entry per <c>INotification</c>
                    the <c>Mediator</c> is interested in.
                </para>
            </remarks>
            <param name="notification"></param>
        </member>
        <member name="M:PureMVC.Patterns.Mediator.Mediator.OnRegister">
            <summary>
            Called by the View when the Mediator is registered
            </summary>
        </member>
        <member name="M:PureMVC.Patterns.Mediator.Mediator.OnRemove">
            <summary>
            Called by the View when the Mediator is removed
            </summary>
        </member>
        <member name="P:PureMVC.Patterns.Mediator.Mediator.MediatorName">
            <summary>the mediator name</summary>
        </member>
        <member name="P:PureMVC.Patterns.Mediator.Mediator.ViewComponent">
            <summary>The view component</summary>
        </member>
        <member name="T:PureMVC.Patterns.Observer.Notification">
            <summary>
            A base <c>INotification</c> implementation.
            </summary>
            <remarks>
                <para>
                    PureMVC does not rely upon underlying event models such 
                    as the one provided with Flash, and ActionScript 3 does 
                    not have an inherent event model.
                </para>
                <para>
                    The Observer Pattern as implemented within PureMVC exists 
                    to support event-driven communication between the 
                    application and the actors of the MVC triad.
                </para>
                <para>
                    Notifications are not meant to be a replacement for Events
                    in Flex/Flash/Apollo. Generally, <c>IMediator</c> implementors
                    place event listeners on their view components, which they
                    then handle in the usual way. This may lead to the broadcast of <c>Notification</c>s to 
                    trigger <c>ICommand</c>s or to communicate with other <c>IMediators</c>. 
                    <c>IProxy</c> and <c>ICommand</c>
                    instances communicate with each other and <c>IMediator</c>s
                    by broadcasting <c>INotification</c>s.
                </para>
                <para>
                    A key difference between Flash <c>Event</c>s and PureMVC
                    <c>Notification</c>s is that <c>Event</c>s follow the 
                    'Chain of Responsibility' pattern, 'bubbling' up the display hierarchy 
                    until some parent component handles the <c>Event</c>, while
                    PureMVC <c>Notification</c>s follow a 'Publish/Subscribe'
                    pattern. PureMVC classes need not be related to each other in a 
                    parent/child relationship in order to communicate with one another
                    using <c>Notification</c>s.
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Patterns.Observer.Observer"/>
        </member>
        <member name="M:PureMVC.Patterns.Observer.Notification.#ctor(System.String,System.Object,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">name of the <c>Notification</c> instance. (required)</param>
            <param name="body">the <c>Notification</c> body. (optional)</param>
            <param name="type">the type of the <c>Notification</c> (optional)</param>
        </member>
        <member name="M:PureMVC.Patterns.Observer.Notification.ToString">
            <summary>
            Get the string representation of the <c>Notification</c> instance.
            </summary>
            <returns>the string representation of the <c>Notification</c> instance.</returns>
        </member>
        <member name="P:PureMVC.Patterns.Observer.Notification.Name">
            <summary>the name of the notification instance</summary>
        </member>
        <member name="P:PureMVC.Patterns.Observer.Notification.Body">
            <summary>the body of the notification instance</summary>
        </member>
        <member name="P:PureMVC.Patterns.Observer.Notification.Type">
            <summary>the type of the notification instance</summary>
        </member>
        <member name="T:PureMVC.Patterns.Observer.Notifier">
            <summary>
            A Base <c>INotifier</c> implementation.
            </summary>
            <remarks>
                <para>
                    <c>MacroCommand, Command, Mediator</c> and <c>Proxy</c> 
                    all have a need to send <c>Notifications</c>.
                </para>
                <para>
                    The <c>INotifier</c> interface provides a common method called
                    <c>sendNotification</c> that relieves implementation code of 
                    the necessity to actually construct <c>Notifications</c>.
                </para>
                <para>
                    The <c>Notifier</c> class, which all of the above mentioned classes
                    extend, provides an initialized reference to the <c>Facade</c>
                    Singleton, which is required for the convienience method
                    for sending <c>Notifications</c>, but also eases implementation as these
                    classes have frequent <c>Facade</c> interactions and usually require
                    access to the facade anyway.
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Patterns.Proxy.Proxy"/>
            <seealso cref="T:PureMVC.Patterns.Facade.Facade"/>
            <seealso cref="T:PureMVC.Patterns.Mediator.Mediator"/>
            <seealso cref="T:PureMVC.Patterns.Command.MacroCommand"/>
            <seealso cref="T:PureMVC.Patterns.Command.SimpleCommand"/>
        </member>
        <member name="M:PureMVC.Patterns.Observer.Notifier.SendNotification(System.String,System.Object,System.String)">
            <summary>
            Create and send an <c>INotification</c>.
            </summary>
            <remarks>
                <para>
                    Keeps us from having to construct new INotification 
                    instances in our implementation code.
                </para>
            </remarks>
            <param name="notificationName">the name of the notiification to send</param>
            <param name="body">the body of the notification (optional)</param>
            <param name="type">the type of the notification (optional)</param>
        </member>
        <member name="P:PureMVC.Patterns.Observer.Notifier.Facade">
            <summary>Return the Singleton Facade instance</summary>
        </member>
        <member name="T:PureMVC.Patterns.Observer.Observer">
            <summary>
            A base <c>IObserver</c> implementation.
            </summary>
            <remarks>
                <para>
                    An <c>Observer</c> is an object that encapsulates information
                    about an interested object with a method that should 
                    be called when a particular <c>INotification</c> is broadcast. 
                </para>
                <para>
                    In PureMVC, the <c>Observer</c> class assumes these responsibilities:
                    <list type="bullet">
                        <item>Encapsulate the notification (callback) method of the interested object.</item>
                        <item>Encapsulate the notification context (this) of the interested object.</item>
                        <item>Provide methods for setting the notification method and context.</item>
                        <item>Provide a method for notifying the interested object.</item>
                    </list>
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Core.View"/>
            <seealso cref="T:PureMVC.Patterns.Observer.Notification"/>
        </member>
        <member name="M:PureMVC.Patterns.Observer.Observer.#ctor(System.Action{PureMVC.Interfaces.INotification},System.Object)">
            <summary>
            Constructor.
            </summary>
            <remarks>
                <para>
                    The notification method on the interested object should take 
                    one parameter of type <c>INotification</c>
                </para>
            </remarks>
            <param name="notifyMethod">the notification method of the interested object</param>
            <param name="notifyContext">the notification context of the interested object</param>
        </member>
        <member name="M:PureMVC.Patterns.Observer.Observer.NotifyObserver(PureMVC.Interfaces.INotification)">
            <summary>
            Notify the interested object.
            </summary>
            <param name="Notification">the <c>INotification</c> to pass to the interested object's notification method.</param>
        </member>
        <member name="M:PureMVC.Patterns.Observer.Observer.CompareNotifyContext(System.Object)">
            <summary>
            Compare an object to the notification context. 
            </summary>
            <param name="obj">the object to compare</param>
            <returns>indicating if the object and the notification context are the same</returns>
        </member>
        <member name="P:PureMVC.Patterns.Observer.Observer.NotifyMethod">
            <summary>Callback method</summary>
        </member>
        <member name="P:PureMVC.Patterns.Observer.Observer.NotifyContext">
            <summary>Context object</summary>
        </member>
        <member name="T:PureMVC.Patterns.Proxy.Proxy">
            <summary>
            A base <c>IProxy</c> implementation. 
            </summary>
            <remarks>
                <para>
                    In PureMVC, <c>Proxy</c> classes are used to manage parts of the 
                    application's data model.
                </para>
                <para>
                     A <c>Proxy</c> might simply manage a reference to a local data object, 
                     in which case interacting with it might involve setting and 
                     getting of its data in synchronous fashion.
                </para>
                <para>
                    <c>Proxy</c> classes are also used to encapsulate the application's 
                    interaction with remote services to save or retrieve data, in which case,
                    we adopt an asyncronous idiom; setting data (or calling a method) on the 
                    <c>Proxy</c> and listening for a <c>Notification</c> to be sent 
                    when the <c>Proxy</c> has retrieved the data from the service.
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Core.Model"/>
        </member>
        <member name="F:PureMVC.Patterns.Proxy.Proxy.NAME">
            <summary> Name of the proxy</summary>
        </member>
        <member name="M:PureMVC.Patterns.Proxy.Proxy.#ctor(System.String,System.Object)">
            <summary>
            Constructor.
            </summary>
            <param name="proxyName"></param>
            <param name="data"></param>
        </member>
        <member name="M:PureMVC.Patterns.Proxy.Proxy.OnRegister">
            <summary>
            Called by the Model when the Proxy is registered
            </summary>
        </member>
        <member name="M:PureMVC.Patterns.Proxy.Proxy.OnRemove">
            <summary>
            Called by the Model when the Proxy is removed
            </summary>
        </member>
        <member name="P:PureMVC.Patterns.Proxy.Proxy.ProxyName">
            <summary>the proxy name</summary>
        </member>
        <member name="P:PureMVC.Patterns.Proxy.Proxy.Data">
            <summary>the data object</summary>
        </member>
    </members>
</doc>
